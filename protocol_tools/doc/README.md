

# `codec_JSON` examples

The JSON encoder offers the option to substitute atoms contained in the
input data with arbitrary values. The atoms can optionally be encoded as
string values if the encoder is called with the option switch turned on:

    1> Out = codec_JSON:encode(
      {1,c,{3,4,#{"a" => a, "b" => b}}},
      #{atomic_names => true}).
    <<"[1,\"c\",[3,4,{\"b\":\"b\",\"a\":\"a\"}]]">>
    2> io:put_chars([Out,$\n]).
    [1,"c",[3,4,{"b":"b","a":"a"}]]
    ok

The default is to handle atoms by requesting substitutions as these are
encountered while processing the input data.

Kick off the encoding process by offering data that contains `atom()`
symbols to represent place-holders:

    1> {c,Fn0} = codec_JSON:encode({1,c,{3,4,#{"a" => a, "b" => b}}}).
    {c,#Fun<codec_JSON.1.26682825>}

The encoder returns a two-tuple, the first element is the atom `'c'`, this
serves as a key to identify what value to insert at that position.  Here we
choose to insert an array `{11,22,33}` (Erlang tuples are encoded as JSON
arrays).

The returned function in `1>` is called with the `{11,22,33}` substitution
for `'c'` in the encoded output.  The next place-holder returned by the
encoder is the atom `'b'`:

    2> {b,Fn1} = Fn0({11,22,33}).
    {b,#Fun<codec_JSON.1.26682825>}

For `'b'` the object `#{"cc" => 44, "dd" => 55}` is substituted (Erlang maps
are encoded as JSON objects):

    3> {a,Fn2} = Fn1(#{"cc" => 44, "dd" => 55}).
    {a,#Fun<codec_JSON.1.26682825>}

The last place-holder is atom `'a'`, which is substituted with a string
value `"END"`:

    4> Bin = Fn2("END").
    <<"[1,[11,22,33],[3,4,{\"b\":{\"dd\":55,\"cc\":44},\"a\":\"END\"}]]">>

Display the encoded binary in more friendly fashion:

    5> io:put_chars([Bin,$\n]).
    [1,[11,22,33],[3,4,{"b":{"dd":55,"cc":44},"a":"END"}]]
    ok

The above substitution values can be provided to the enoder as a map:

    6> codec_JSON:encode(
         {1,c,{3,4,#{"a" => a, "b" => b}}},
         #{ substitute_map =>
            #{ a => "END",
               b => #{"cc" => 44, "dd" => 55},
               c => {11,22,33} } } ).
    <<"[1,[11,22,33],[3,4,{\"b\":{\"dd\":55,\"cc\":44},\"a\":\"END\"}]]">>

The substitutions are recursive: If the substitute also contains atoms,
these will either be fetched from the `substitute_map`, or control is passed
back to the caller to decide.

    7> codec_JSON:encode(
         {1,c,{3,4,#{"a" => a, "b" => b}}},
         #{ substitute_map =>
            #{ a => "END",
               b => #{"cc" => cc, "dd" => dd}, % contains atoms
               c => {11,22,33},
               cc => 4444,
               dd => 5555 } } ).
    <<"[1,[11,22,33],[3,4,{\"b\":{\"dd\":5555,\"cc\":4444},\"a\":\"END\"}]]">>

Recursion depth is limited by default to 1000. The limit value can be
specified as an option:

    8> codec_JSON:encode(
         {1,c,{3,4,#{"a" => a, "b" => b}}},
         #{ looplimit => 123,
            substitute_map =>
            #{ a => a,
               b => b,
               c => c } } ).
    ** exception throw: looplimit
         in function  codec_JSON:encode_substitutions/2 (codec_JSON.erl, line 88)








# Extract data from XSD

The `decode_XML` module demonstrates how to parse XML data, and to
manipulate this data. The example below uses data from the ISO20022 message
definition contained in an XSD file.

Load the entire binary data from the XSD file:

    1> {ok,Bin} = file:read_file("protocol_tools/priv/pacs.002.001.13.xsd").
    {ok,<<"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
          "<!--Generated by Standards Editor (build:R1.6.22)"
          " on 2023 Feb 09 10:"...>>}

First pass decode of the XML data in the binary:

    2> Pacs002 = codec_xml:decode(Bin).
    [{prolog,<<"xml version=\"1.0\" encoding=\"UTF-8\"">>},
     {comment,
         <<"Generated by Standards Editor (build:R1.6.22)"
           " on 2023 Feb 09 10:22:51, ISO 20022 version : 2013">>},
     {element,<<"xs:schema">>,
         #{<<"elementFormDefault">> => <<"qualified">>,
           <<"targetNamespace">> =>
               <<"urn:iso:std:iso:20022:tech:xsd:pacs.002.001.13">>,
           <<"xmlns">> =>
               <<"urn:iso:std:iso:20022:tech:xsd:pacs.002.001.13">>,
           <<"xmlns:xs">> => <<"http://www.w3.org/2001/XMLSchema">>},
         [<<"\r\n    ">>,
          {element,<<"xs:element">>,
              #{<<"name">> => <<"Document">>,<<"type">> => <<"Document">>},
              empty},
          <<"\r\n    ">>,
          {element,<<"xs:complexType">>,
              #{<<"name">> => <<"AccountIdentification4Choice">>},
              [<<"\r\n        ">>,
               {element,<<"xs:choice">>,#{},
                   [<<"\r\n            ">>,
                    {element,<<"xs:element">>,
                        #{<<"name">> => <<"IBAN">>,
                          <<"type">> => <<"IBAN2007"...>>},
                        empty},
                    <<"\r\n            ">>,
                    {element,<<"xs:eleme"...>>,
                        #{<<...>> => <<...>>,...},
                        empty},
                    <<"\r\n        ">>]},
               <<"\r\n    ">>]},
          <<"\r\n    ">>,{...}|...]}]

Inspect the raw text embedded in the markup. This is all whitespace, and the
result is an empty binary after the leading spaces are trimmed:

    3> schema_xsd:raw_text(Pacs002).
    <<>>

The XML namespace prefixes are garbage, get rid of that design-by-committee
junk:

    4> Trim = schema_xsd:trim_namespace(Pacs002).

Now we can see the trees in the woods. the result is a searchable Schema
represented as a map:

    5> Schema = schema_xsd:from_document(Trim).
    #{{typedef,<<"ISOYear">>} =>
          #{name => <<"ISOYear">>,type => year},
      {typedef,<<"SettlementInstruction11">>} =>
          #{name => <<"SettlementInstruction11">>,
            sequence =>
                [{element,#{name => <<"SttlmMtd">>,
                            type => <<"SettlementMethod1Code">>}},
                 {element,#{name => <<"SttlmAcct">>,type => <<"CashAccount40">>,
                            maxOccurs => 1,minOccurs => 0}},
                 {element,#{name => <<"ClrSys">>,
                            type => <<"ClearingSystemIdentification3Choice">>,
                            maxOccurs => 1,minOccurs => 0}},
                 {element,#{name => <<"InstgRmbrsmntAgt">>,
                            type =>
                                <<"BranchAndFinancialInstitutionIdentification6">>,
                            maxOccurs => 1,minOccurs => 0}},
                 {element,#{name => <<"InstgRmbrsmntAgtAcct">>,
                            type => <<"CashAccount40">>,maxOccurs => 1,
                            minOccurs => 0}},
                 {element,#{name => <<"InstdRmbrsmntAgt">>,
                            type =>
                                <<"BranchAndFinancialInstitutionIdentification6">>,
                            maxOccurs => 1,minOccurs => 0}},
                 {element,#{name => <<"InstdRmbrsmntAgtAcct">>,
                            type => <<"CashAccount40">>,maxOccurs => 1,
                            minOccurs => 0}},
                 {element,#{name => <<"ThrdRmbrsmntAgt">>,
                            type =>
                                <<"BranchAndFinancialInstitutionIdentification6">>,
                            maxOccurs => 1,minOccurs => 0}},
                 {element,#{name => <<"ThrdRmbrsmntAgtAcct">>,
                            type => <<"CashAccount40">>,maxOccurs => 1,
                            minOccurs => 0}}]},
      {typedef,<<"Purpose2Choice">>} =>
          #{name => <<"Purpose2Choice">>,
            choice =>
                [{element,#{name => <<"Cd">>,type => <<"ExternalPurpose1Code">>}},
                 {element,#{name => <<"Prtry">>,type =><<"Max35Text">>}}]},...}

The XSD top-level is a `Document` element:

    6> maps:get({element,<<"Document">>},Schema).
    #{name => <<"Document">>,
      type => <<"Document">>}

The type definition is also called `Document`, hence the distinct `element`
and `typedef` tuple keys.

    7> maps:get({typedef,<<"Document">>},Schema).
    #{name => <<"Document">>,
      sequence =>
          [{element,#{name => <<"FIToFIPmtStsRpt">>,
                      type => <<"FIToFIPaymentStatusReportV13">>}}]}

It is now possible to search for the `type` that encodes the `Document`
contents, in a type called `FIToFIPaymentStatusReportV13`:

    8> maps:get({typedef,<<"FIToFIPaymentStatusReportV13">>},Schema).
    #{name => <<"FIToFIPaymentStatusReportV13">>,
      sequence =>
          [{element,#{name => <<"GrpHdr">>,
                      type => <<"GroupHeader101">>}},
           {element,#{name => <<"OrgnlGrpInfAndSts">>,
                      type => <<"OriginalGroupHeader17">>,
                      minOccurs => 0,
                      maxOccurs => infinity}},
           {element,#{name => <<"TxInfAndSts">>,
                      type => <<"PaymentTransaction142">>,
                      minOccurs => 0,
                      maxOccurs => infinity}},
           {element,#{name => <<"SplmtryData">>,
                      type => <<"SupplementaryData1">>,
                      minOccurs => 0,
                      maxOccurs => infinity}}]}

Within the `FIToFIPaymentStatusReportV13` there is a sequence of elements:

    9> maps:get({typedef,<<"GroupHeader101">>},Schema).
    #{name => <<"GroupHeader101">>,
      sequence =>
          [{element,#{name => <<"MsgId">>,
                      type => <<"Max35Text">>}},
           {element,#{name => <<"CreDtTm">>,
                      type => <<"ISODateTime">>}},
           {element,#{name => <<"InstgAgt">>,
                      type => <<"BranchAndFinancialInstitutionIdentification6">>,
                      minOccurs => 0,
                      maxOccurs => 1}},
           {element,#{name => <<"InstdAgt">>,
                      type => <<"BranchAndFinancialInstitutionIdentification6">>,
                      minOccurs => 0,
                      maxOccurs => 1}},
           {element,#{name => <<"OrgnlBizQry">>,
                      type => <<"OriginalBusinessQuery1">>,
                      minOccurs => 0,
                      maxOccurs => 1}}]}

One of those elements is called `ISODateTime`. Lets have a closer look at
that type definition:

    10> maps:get({typedef,<<"ISODateTime">>},Schema).
    #{name => <<"ISODateTime">>,
      type => dateTime}

This is a fundamental type that e.g. a message generator can produce
random (or restrained) values for.

The range of fundamental types identified so far in the example above are:

* `date`
* `dateTime`
* `gYear`
* `boolean`
* `base64Binary`
* `decimal`
* `string`

These fundamental types can be combined to compose either a simpleType or a
complexType.

The composition of a complexType can either be:

* `simpleContent`
* `sequence`
* `choice`



# Testing XML generation


    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"AddressType2Code">>,
        Schema ) ).
    <<"<AddressType2Code>DLVY</AddressType2Code>">>

The `GenericIdentification30` contains an instance of `AddressType2Code`:

    io:put_chars([
    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"GenericIdentification30">>,
        Schema)),$\n]).
    <GenericIdentification30>
      <Id>Generated value of Exact4AlphaNumericText</Id>
      <Issr>Generated value of Max35Text</Issr>
      <SchmeNm>Generated value of Max35Text</SchmeNm>
    </GenericIdentification30>

Generating forms that contain the above:

    io:put_chars([
    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"AddressType3Choice">>,
        Schema)),$\n]).
    <AddressType3Choice>
      <Prtry>
        <GenericIdentification30>
          <Id>Generated value of Exact4AlphaNumericText</Id>
          <Issr>Generated value of Max35Text</Issr>
          <SchmeNm>Generated value of Max35Text</SchmeNm>
        </GenericIdentification30>
      </Prtry>
    </AddressType3Choice>



    file:write_file("tmp.xml",
    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"PostalAddress24">>,
        Schema ) ) ).

    #> tidy -xml -indent <tmp.xml
    <PostalAddress24>
      <AdrTp>
        <AddressType3Choice>
          <Cd>
            <AddressType2Code>DLVY</AddressType2Code>
          </Cd>
        </AddressType3Choice>
      </AdrTp>
      <Dept>Generated value of Max70Text</Dept>
      <SubDept>Generated value of Max70Text</SubDept>
      <StrtNm>Generated value of Max70Text</StrtNm>
      <BldgNb>Generated value of Max16Text</BldgNb>
      <BldgNm>Generated value of Max35Text</BldgNm>
      <Flr>Generated value of Max70Text</Flr>
      <PstBx>Generated value of Max16Text</PstBx>
      <Room>Generated value of Max70Text</Room>
      <PstCd>Generated value of Max16Text</PstCd>
      <TwnNm>Generated value of Max35Text</TwnNm>
      <TwnLctnNm>Generated value of Max35Text</TwnLctnNm>
      <DstrctNm>Generated value of Max35Text</DstrctNm>
      <CtrySubDvsn>Generated value of Max35Text</CtrySubDvsn>
      <Ctry>Generated value of CountryCode</Ctry>
      <AdrLine>Generated value of Max70Text</AdrLine>
    </PostalAddress24>



    file:write_file("tmp.xml",
    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"BranchData3">>,
        Schema ) ) ).

     #> tidy -xml -indent <tmp.xml
     <BranchData3>
       <Id>Generated value of Max35Text</Id>
       <LEI>Generated value of LEIIdentifier</LEI>
       <Nm>Generated value of Max140Text</Nm>
       <PstlAdr>
         <PostalAddress24>
           <AdrTp>
             <AddressType3Choice>
               <Prtry>
                 <GenericIdentification30>
                   <Id>Generated value of Exact4AlphaNumericText</Id>
                   <Issr>Generated value of Max35Text</Issr>
                   <SchmeNm>Generated value of Max35Text</SchmeNm>
                 </GenericIdentification30>
               </Prtry>
             </AddressType3Choice>
           </AdrTp>
           <Dept>Generated value of Max70Text</Dept>
           <SubDept>Generated value of Max70Text</SubDept>
           <StrtNm>Generated value of Max70Text</StrtNm>
           <BldgNb>Generated value of Max16Text</BldgNb>
           <BldgNm>Generated value of Max35Text</BldgNm>
           <Flr>Generated value of Max70Text</Flr>
           <PstBx>Generated value of Max16Text</PstBx>
           <Room>Generated value of Max70Text</Room>
           <PstCd>Generated value of Max16Text</PstCd>
           <TwnNm>Generated value of Max35Text</TwnNm>
           <TwnLctnNm>Generated value of Max35Text</TwnLctnNm>
           <DstrctNm>Generated value of Max35Text</DstrctNm>
           <CtrySubDvsn>Generated value of Max35Text</CtrySubDvsn>
           <Ctry>Generated value of CountryCode</Ctry>
           <AdrLine>Generated value of Max70Text</AdrLine>
         </PostalAddress24>
       </PstlAdr>
     </BranchData3>

    io:put_chars([
    codec_xml:encode(
      schema_xsd:generate_from_schema(
        <<"LEIIdentifier">>,
        Schema)),$\n]).

    96CI7P89WNB89VCHD793
    6VKUN06NDXQ17DPNXD31
    DZOIMKH625RVYPIWHB58


Generating from string patterns:

    make_value:from_regexp(
      <<"[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}"
        "-[89ab][a-f0-9]{3}-[a-f0-9]{12}">>).
    <<"70e74fa2-c87a-4d99-b3cc-061db627e2d1">>

    Patterns =
     [<<"[A-Z]{3,3}">>,
      <<"[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}">>,
      <<"[A-Z]{2,2}">>,
      <<"[0-9]{2}">>,
      <<"[a-zA-Z0-9]{4}">>,
      <<"[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}">>,
      <<"[A-Z0-9]{18,18}[0-9]{2,2}">>,
      <<"[0-9]{1,15}">>,
      <<"\+[0-9]{1,3}-[0-9()+\-]{1,30}">>,
      <<"[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}"
        "-[89ab][a-f0-9]{3}-[a-f0-9]{12}">>].

    [make_value:from_regexp(P) || P <- Patterns].

Example output for the above patterns found in the XSD file:

    [<<"HGO">>,
     <<"X6QLEIOT(9KJ)">>,
     <<"GO">>,
     <<"31">>,
     <<"VkVj">>,
     <<"OT82zWVZ6YY58rfEuyiaPpX7cdgciF1">>,
     <<"D5VLRCJWQ0XNCUO9RY80">>,
     <<"78">>,
     <<"+92-(37(68))631+44+)6(0+448-0">>,
     <<"914a953e-03b1-421c-841b-56e709b21f3a">>]

    [<<"VDX">>,
     <<"98S9GO74(FPI)">>,
     <<"AU">>,
     <<"36">>,
     <<"UV1I">>,
     <<"RJ18nk0p0UddP1GCm6A3O9tAZxL5BK9b">>,
     <<"RCAMHLLLS0P1X09NWN02">>,
     <<"1537">>,
     <<"+37-82)8(0)1269106---8578">>,
     <<"bda7489b-232c-4cf5-9d57-c9107d7d4a88">>]

    [<<"HDY">>,
     <<"C3Y6IDTD(QY5)">>,
     <<"GX">>,
     <<"70">>,
     <<"uxm6">>,
     <<"AT94R317C6I2bijxB">>,
     <<"5GJ0BJ4VIGACY3QDQ557">>,
     <<"43937857435385">>,
     <<"+543-530-(-0+357626-71(70">>,
     <<"64b5d8ff-5ed0-4e6a-9a5e-37065642c1c6">>]



------------------------------------------------


# Manual testing recipies:

    1> {ok,Bin} = file:read_file("protocol_tools/priv/pacs.002.001.13.xsd").
    2> Pacs002 = codec_xml:decode(Bin).
    3> Trim = schema_xsd:trim_namespace(Pacs002).
    4> Schema = schema_xsd:from_document(Trim).

    5> maps:get({element,<<"Document">>},Schema).
    #{name => <<"Document">>,type => <<"Document">>}

    6> maps:get({typedef,<<"Document">>},Schema).
    {sequence,[{element,#{name => <<"FIToFIPmtStsRpt">>,
                          type => <<"FIToFIPaymentStatusReportV13">>}}]}

The following is expected to fail:

    try maps:get({typedef,<<"FIToFIPmtStsRpt">>},Schema) catch What:Why ->
    {What,Why} end.
    {error,{badkey,{typedef,<<"FIToFIPmtStsRpt">>}}}

Successful lookup results:

    maps:get({typedef,<<"FIToFIPaymentStatusReportV13">>},Schema).
    #{name => <<"FIToFIPaymentStatusReportV13">>,
      sequence =>
          [{element,#{name => <<"GrpHdr">>,
                      type => <<"GroupHeader101">>}},
           {element,#{name => <<"OrgnlGrpInfAndSts">>,
                      type => <<"OriginalGroupHeader17">>,
                      minOccurs => 0,
                      maxOccurs => infinity}},
           {element,#{name => <<"TxInfAndSts">>,
                      type => <<"PaymentTransaction142">>,
                      minOccurs => 0,
                      maxOccurs => infinity}},
           {element,#{name => <<"SplmtryData">>,
                      type => <<"SupplementaryData1">>,
                      minOccurs => 0,
                      maxOccurs => infinity}}]}


    maps:get({typedef,<<"GroupHeader101">>},Schema).
    #{name => <<"GroupHeader101">>,
      sequence =>
          [{element,#{name => <<"MsgId">>,
                      type => <<"Max35Text">>}},
           {element,#{name => <<"CreDtTm">>,
                      type => <<"ISODateTime">>}},
           {element,#{name => <<"InstgAgt">>,
                      type => <<"BranchAndFinancialInstitutionIdentification6">>,
                      minOccurs => 0,
                      maxOccurs => 1}},
           {element,#{name => <<"InstdAgt">>,
                      type => <<"BranchAndFinancialInstitutionIdentification6">>,
                      minOccurs => 0,
                      maxOccurs => 1}},
           {element,#{name => <<"OrgnlBizQry">>,
                      type => <<"OriginalBusinessQuery1">>,
                      minOccurs => 0,
                      maxOccurs => 1}}]}


    maps:get({typedef,<<"Max35Text">>},Schema).
    #{name => <<"Max35Text">>,
      type => string,
      minLength => 1,
      maxLength => 35}


    maps:get({typedef,<<"AddressType2Code">>},Schema).
    #{name => <<"AddressType2Code">>,
      type => string,
      enumeration =>
          [<<"ADDR">>,
           <<"PBOX">>,
           <<"HOME">>,
           <<"BIZZ">>,
           <<"MLTO">>,
           <<"DLVY">>]}


    maps:get({typedef,<<"ActiveOrHistoricCurrencyCode">>},Schema).
    #{name => <<"ActiveOrHistoricCurrencyCode">>,
      type => string,
      pattern => <<"[A-Z]{3,3}">>}


    maps:get({typedef,<<"Frequency36Choice">>},Schema).
    #{name => <<"Frequency36Choice">>,
      choice =>
          [{element,#{name => <<"Tp">>,
                      type => <<"Frequency6Code">>}},
           {element,#{name => <<"Prd">>,
                      type => <<"FrequencyPeriod1">>}},
           {element,#{name => <<"PtInTm">>,
                      type => <<"FrequencyAndMoment1">>}}]}


    maps:get({typedef,<<"Max10KBinary">>},Schema).
    #{name => <<"Max10KBinary">>,
      type => base64,
      minLength => 1,
      maxLength => 10240}

    maps:get(
      {typedef,<<"ActiveOrHistoricCurrencyAndAmount_SimpleType">>},
      Schema).
    #{name => <<"ActiveOrHistoricCurrencyAndAmount_SimpleType">>,
      type => decimal,
      fractionDigits => 5,
      totalDigits => 18,
      minInclusive => 0}








# Generate XML from XSD - example

Date: 2024-05-02T10:08
Location: phm@SugoiRingo:~/Repos/Workshop/sandpit


Write to `tmp.xml` the XML message generated from the XSD file
`camt.053.001.11.xsd`:

    file:write_file(
      "tmp.xml",
      codec_xml:encode(
        schema_xsd:generate_from_XSD_file(
          "protocol_tools/priv/camt.053.001.11.xsd" ) ) ).

The result (fragment):

    #> tidy -xml -indent \
       < tmp.xml \
       | head -100
    No warnings or errors were found.

    <Document>
      <BkToCstmrStmt>
        <BankToCustomerStatementV11>
          <GrpHdr>
            <GroupHeader81>
              <MsgId>ZNzfKC0iHz4POPl0Ak</MsgId>
              <CreDtTm>Generated value of ISODateTime</CreDtTm>
              <MsgRcpt>
                <PartyIdentification135>
                  <Nm>
                  2XbgTc3hGcsww6LGS7YKeZakjYbCbE4MI7osO0eWrSoQqIopiMwAMfSxZLiwUfUQuMYkrSIiF7
                  0ncMF5qFr6JiF9FPEoeLqVuhHCOA6nff</Nm>
                  <PstlAdr>
                    <PostalAddress24>
                      <AdrTp>
                        <AddressType3Choice>
                          <Prtry>
                            <GenericIdentification30>
                              <Id>Lxum</Id>
                              <Issr>sQ6BvS4hRiLtr31c02</Issr>
                              <SchmeNm>0duPO</SchmeNm>
                            </GenericIdentification30>
                          </Prtry>
                        </AddressType3Choice>
                      </AdrTp>
                      <Dept>Pi90SVfGJmVcZ76YFeOeQYDO
                      iDtTjajNXaTcwzElV3Cf</Dept>
                      <SubDept>CHaW1pjkULJtSYE2xf</SubDept>
                      <StrtNm>mb6GiNREVOh1qMW4o6aJ
                      kV6sQcRf5Ll80srRvTdBaMps KmlGCO8ItQiE2x</StrtNm>
                      <BldgNb>MJyofU0O6cMcK</BldgNb>
                      <BldgNm>XeomCPf7Fr8IOa4M
                      j3pxFNgjLOhnkoWc</BldgNm>
                      <Flr>4w6lRHPJA8cUKHJ0NPl5jQu8PrEErh4fg3eU</Flr>
                      <PstBx>gtzZwDt</PstBx>
                      <Room>Nk1psE20gcav9njX</Room>
                      <PstCd>5F3qMi2 b</PstCd>
                      <TwnNm>Zo6fVdBkgLm3hmGL62l XNIzP</TwnNm>
                      <TwnLctnNm>kfSjIFFi</TwnLctnNm>
                      <DstrctNm>G0ShpUiWjIq</DstrctNm>
                      <CtrySubDvsn>
                      KtEBV7QXKckmTiMzRQhVjUrM</CtrySubDvsn>
                      <Ctry>SZ</Ctry>
                      <AdrLine>jrBKfRxl5hM8QDqHc8c2QMghhbwuf</AdrLine>
                    </PostalAddress24>
                  </PstlAdr>
                  <Id>
                    <Party38Choice>
                      <OrgId>
                        <OrganisationIdentification29>
                          <AnyBIC>O5N1LABZ(UWH)</AnyBIC>
                          <LEI>HTNES9FFMT1ALBFVOF39</LEI>
                          <Othr>
                            <GenericOrganisationIdentification1>
                              <Id>6tCuP7kY7aBPavQf8</Id>
                              <SchmeNm>
                                <OrganisationIdentificationSchemeName1Choice>

                                  <Prtry>T66m8UcxgVRnoXgHP75</Prtry>
                                </OrganisationIdentificationSchemeName1Choice>
                              </SchmeNm>
                              <Issr>61fDvewPRtA zMoc2wy</Issr>
                            </GenericOrganisationIdentification1>
                          </Othr>
                        </OrganisationIdentification29>
                      </OrgId>
                    </Party38Choice>
                  </Id>
                  <CtryOfRes>SB</CtryOfRes>
                  <CtctDtls>
                    <Contact4>
                      <NmPrfx>
                        <NamePrefix2Code>MIKS</NamePrefix2Code>
                      </NmPrfx>
                      <Nm>B7 YIgdelxQCRG03IFk</Nm>
                      <PhneNb>+50-152(((36(</PhneNb>
                      <MobNb>+770-7)+3655417-2+5)80+5871+19+5</MobNb>
                      <FaxNb>+60-44)85+8</FaxNb>
                      <EmailAdr>GSpZhkNHYapKU0RpOziCdEVhmu4YZGmZm5
                      3z9bNYaGl0RldXN3o6crv7ObzyYpbObpbAhIGXjr3TYVI8BqTzI08gp2Q22qbSXTHf0FDXRYbLHQk
                      MJkoQNxdhJaRVAMtspfQX7bhL73gWG1N
                      fclgEeZYSVbPmEBsBE
                      3VFVF0VeIHPUzB6AeKElzrHPMwD8PcPYeOYgjxxUkH9fjTa0AQp7gGJTdrc
                      3L nFIN6t40HJnj8wO7H5bcBd5XIqLY3tDne
                      olfH6OojhFoRMoUYy32SwFYWeVWcASlPDuwm
                      T7CUyIrUEwJqCyydMnJUy2ArL9i7oC7y0hlAbwK16zO5ZI
                      Brv6pVxzhyaaGYs3sVw1wgi6e3PldMgSk6xB0ffThnqqQ3QTOlghZwYl1pbPuNKBOxFwv7phlfAeMFlyELTIamqigODjaRkGfwOcoBbqCLXv2rW0cSzzK2aqweyEOexjGKotn9wVdfImBKRNC58B
                      KUgzYeRIHqt0wwKmXneWyEbK5UoBEqRqknaqndizQzXbxn1bv7asL1IPvRY7PIRpvsypRyvLCZiIjZmb7y</EmailAdr>
                      <EmailPurp>NLzD</EmailPurp>
                      <JobTitl>GW1fXtixq</JobTitl>
                      <Rspnsblty>pFqAs3 uwoih6bkA0D
                      5QtDbqJ1</Rspnsblty>
                      <Dept>av2Hz23G8fAQt744OCYhYsrAXpuXvGc
                      qhiaqA</Dept>
                      <Othr>
                        <OtherContact1>
                          <ChanlTp>rcS</ChanlTp>
                          <Id>
                          t0ySYwswpAZnqlNsQ7sB6aYxGoB1pj0GqHA4tIxYOSvMOpAMVQ5rXuFM</Id>
                        </OtherContact1>

Tested against the following XSD files:

    #> ls -1 ./protocol_tools/priv/*.xsd
    ./protocol_tools/priv/camt.053.001.11.xsd
    ./protocol_tools/priv/camt.054.001.11.xsd
    ./protocol_tools/priv/pacs.002.001.13.xsd
    ./protocol_tools/priv/pacs.003.001.10.xsd
    ./protocol_tools/priv/pacs.004.001.12.xsd
    ./protocol_tools/priv/pacs.007.001.12.xsd
    ./protocol_tools/priv/pacs.008.001.11.xsd



# Extract the namespace from XSD, add XML prolog to output


## PACS008

The XSD for PACS.008 contains a `targetNamespace` value of
`"urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11"`:

    #> tidy -xml -indent <protocol_tools/priv/pacs.008.001.11.xsd | head
    No warnings or errors were found.

    <?xml version="1.0" encoding="utf-8"?>
    <!--Generated by Standards Editor (build:R1.6.22) on 2023 Feb 09 10:22:51, ISO 20022 version : 2013-->

    <xs:schema
     xmlns="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     elementFormDefault="qualified"
     targetNamespace="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">

      <xs:element name="Document" type="Document" />
      <xs:complexType name="AccountIdentification4Choice">
        <xs:choice>
          <xs:element name="IBAN" type="IBAN2007Identifier" />

Extracting the value of the `targetNamespace` from the schema:

    1> {ok,Bin} = file:read_file("protocol_tools/priv/pacs.008.001.11.xsd").
    2> Pacs008 = codec_xml:decode(Bin).
    3> Trim008 = schema_xsd:trim_namespace(Pacs008).
    4> [{element,<<"schema">>,Attr008,_}] = Trim008.

    5> Attr008.
    #{<<"elementFormDefault">> => <<"qualified">>,
      <<"targetNamespace">> =>
          <<"urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">>,
      <<"xmlns">> =>
          <<"urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">>,
      <<"xmlns:xs">> => <<"http://www.w3.org/2001/XMLSchema">>}

    6> Namespace008 = maps:get(<<"targetNamespace">>,Attr008).
    <<"urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">>

    7> Schema008 = schema_xsd:from_document(Trim008).

    8> maps:get({element,<<"Document">>},Schema008).
    #{name => <<"Document">>,type => <<"Document">>}

    9> maps:get({typedef,<<"Document">>},Schema008).
    #{name => <<"Document">>,
      sequence =>
          [{element,#{name => <<"FIToFICstmrCdtTrf">>,
                      type => <<"FIToFICustomerCreditTransferV11">>}}]}

    10> GenMsg008 = schema_xsd:generate_from_schema(<<"Document">>,Schema008).
    11> {element,<<"Document">>,MsgAtt008,Content008} = GenMsg008.
    12> BinMsg008 = codec_xml:encode(
          { element,
            <<"Document">>,
            MsgAtt008#{ <<"xmlns">> => Namespace008 },
            Content008}).

    13> file:write_file("tmp.xml",BinMsg008).



    file:write_file(
      "tmp.xml",
      codec_xml:encode(
        schema_xsd:generate_from_XSD_file(
          "protocol_tools/priv/pacs.008.001.11.xsd" ) ) ).


The namespace is now inserted into the Document element:

    #> tidy -xml -indent <tmp.xml |head
    No warnings or errors were found.

    <Document xmlns="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">
      <FIToFICstmrCdtTrf>
        <FIToFICustomerCreditTransferV11>
          <GrpHdr>
            <GroupHeader96>
              <MsgId>78xbYiyfbiIZL4Lo</MsgId>
              <CreDtTm>Generated value of ISODateTime</CreDtTm>
              <BtchBookg>FALSE</BtchBookg>
              <NbOfTxs>88652214861624</NbOfTxs>
              <CtrlSum>Generated value of DecimalNumber</CtrlSum>


Match the value of `targetNamespace` with the `Document` namespace in the
example PACS.008 message XML data:

    #> tidy -xml -indent <protocol_tools/priv/pacs008.xml | head -10
    No warnings or errors were found.


    To learn more about HTML Tidy see http://tidy.sourceforge.net
    Please send bug reports to html-tidy@w3.org
    HTML and CSS specifications are available from http://www.w3.org/
    Lobby your company to join W3C, see http://www.w3.org/Consortium
    <?xml version="1.0"?>

    <Document xmlns="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">

      <FIToFICstmrCdtTrf>
        <GrpHdr>
          <MsgId>pacs8bizmsgid6458556</MsgId>
          <CreDtTm>2024-04-30T11:29:49Z</CreDtTm>
          <NbOfTxs>1</NbOfTxs>
          <SttlmInf>
            <SttlmMtd>INDA</SttlmMtd>
          </SttlmInf>






# Deal with `extension` type definition in XSD


In the `protocol_tools/priv/pacs.008.001.11.xsd` file there are two type definitions,
`ActiveCurrencyAndAmount` and `ActiveOrHistoricCurrencyAndAmount` that have
element attributes specified. In both cases the attribute name is `Ccy` and
the value type definition is identical, is a three-letter currency code.


    <xs:simpleType name="ActiveCurrencyAndAmount_SimpleType">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="5"/>
            <xs:totalDigits value="18"/>
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActiveCurrencyAndAmount">
        <xs:simpleContent>
            <xs:extension base="ActiveCurrencyAndAmount_SimpleType">
                <xs:attribute
                 name="Ccy"
                 type="ActiveCurrencyCode"
                 use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="ActiveCurrencyCode">
        <xs:restriction base="xs:string">
            <xs:pattern value="[A-Z]{3,3}"/>
        </xs:restriction>
    </xs:simpleType>


    <xs:simpleType name="ActiveOrHistoricCurrencyAndAmount_SimpleType">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="5"/>
            <xs:totalDigits value="18"/>
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActiveOrHistoricCurrencyAndAmount">
        <xs:simpleContent>
            <xs:extension base="ActiveOrHistoricCurrencyAndAmount_SimpleType">
                <xs:attribute
                 name="Ccy"
                 type="ActiveOrHistoricCurrencyCode"
                 use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="ActiveOrHistoricCurrencyCode">
        <xs:restriction base="xs:string">
            <xs:pattern value="[A-Z]{3,3}"/>
        </xs:restriction>
    </xs:simpleType>


Testing the generators:

    1> {ok,Bin} = file:read_file("protocol_tools/priv/pacs.008.001.11.xsd").
    2> Pacs008 = codec_xml:decode(Bin).
    3> Trim008 = schema_xsd:trim_namespace(Pacs008).
    4> Schema008 = schema_xsd:from_document(Trim008).

    5> maps:get({typedef,<<"ActiveCurrencyCode">>},Schema008).
    #{name => <<"ActiveCurrencyCode">>,type => string,
      pattern => <<"[A-Z]{3,3}">>}

    6> make_value:from_regexp(<<"[A-Z]{3,3}">>).
    <<"AEG">>
    <<"MYU">>
    <<"XFV">>

    7> maps:get({typedef,<<"ActiveCurrencyAndAmount_SimpleType">>},Schema008).
    #{name => <<"ActiveCurrencyAndAmount_SimpleType">>,
      type => decimal,
      totalDigits => 18,
      minInclusive => 0,
      fractionDigits => 5}

    8> schema_xsd:generate_from_schema(
          <<"ActiveCurrencyAndAmount">>,
          decode_XML:schema(Trim008)).

    {element,<<"ActiveCurrencyAndAmount">>,
             #{<<"Ccy">> => [<<"ADG">>]},
             [<<"5475845.3529">>]}
    {element,<<"ActiveCurrencyAndAmount">>,
             #{<<"Ccy">> => [<<"YVO">>]},
             [<<"90350941947070.25649">>]}
    {element,<<"ActiveCurrencyAndAmount">>,
             #{<<"Ccy">> => [<<"UHP">>]},
             [<<"4890.235">>]}
    {element,<<"ActiveCurrencyAndAmount">>,
             #{<<"Ccy">> => [<<"NWZ">>]},
             [<<"83798.14534">>]}
    {element,<<"ActiveCurrencyAndAmount">>,
             #{<<"Ccy">> => [<<"MLV">>]},
             [<<"6854.7353">>]}


## Type definitions for `decimal` values in XSD

    <xs:simpleType name="BaseOneRate">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="10"/>
            <xs:totalDigits value="11"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="DecimalNumber">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="17"/>
            <xs:totalDigits value="18"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="Number">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="0"/>
            <xs:totalDigits value="18"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="PercentageRate">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="10"/>
            <xs:totalDigits value="11"/>
        </xs:restriction>
    </xs:simpleType>

Description of the "restrictions" or "facets" defined above:


xs:totalDigits defines the maximum number of digits of decimal and derived
datatypes (both after and before the decimal point, not counting the decimal
point itself).

xs:fractionDigits defines the maximum number of fractional digits (i.e.,
digits that are after the decimal point) of an xs:decimal datatype.

This facet constrains the value space, which means that the number of
fractional digits is checked after the value is transformed to its canonical
form, and the trailing zeros are removed.

xs:minInclusive defines an inclusive minimum value.  To be valid, a value
must be greater than or equal to the value of xs:minInclusive.

[See also](https://www.w3schools.com/XML/schema_facets.asp)


# Extraction paths


The feature is demonstrated in the unit tests.

During the docoding process, when any element in the XML document happens to
match by name an entry in the atom-table, the decoder will return with the
atom found and a continuation closure that will resume decoding the rest.
See the `codec_xml:hook/1` function.

By itself the `hook` does not extract data in any structured form. This
requires that the "paths" to data in the XML document are specified as
configuration data. The path description must contain atoms matching
elements starting from the top document element through to the element where
the interesting data is.

There are two forms that the extraction path can be specified, either as a
nest of maps, or a nest of tuples. See `codec_xml_test:test_decode/1`

```
  %%
  %%  Extraction paths as nested maps:
  %%
  Y = #{ 'Envelope' =>
         #{ 'Header' => #{},
            'Body' =>
              #{ trigger =>
                 #{ attribute => #{} } } } },

  Elements = path_utils:extraction_paths(Y),

  %%
  %%  Extraction paths as nested tuples:
  %%
  X = {'Envelope',[
        {'Header',[ ]},
        {'Body',[
          {trigger,[
            {attribute,[ ]} ]} ]} ]},

  Elements = path_utils:extraction_paths(X),
```

The above forms are turned "inside-out" to expose each of the paths
individually, so that the extraction implementation can match them to
positions within the XML document.

```
  Elements = #{
    ['Header','Envelope'] => [],
    [attribute,trigger,'Body','Envelope'] => [] },
```

Example output from the unit test:


```
1> codec_xml_test:test().
=NOTICE REPORT==== 14-May-2024::16:01:21.597837 ===
loop:187
	Extracted = #{'Envelope' =>
                          #{'Body' => #{trigger => #{attribute => []}},
                            'Header' => []}}.

=NOTICE REPORT==== 14-May-2024::16:01:21.600638 ===
loop:187
	Extracted = #{'Envelope' =>
                          #{'Body' => #{trigger => #{attribute => []}},
                            'Header' => []}}.

[]
=NOTICE REPORT==== 14-May-2024::16:01:21.600882 ===
loop:187
	Extracted = #{'Envelope' =>
                       #{'Body' =>
                          #{trigger =>
                             #{attribute =>
                                [[{element,<<"trig:beforeValue">>,#{},
                                   [<<"Something that exist">>,
                                    {entity_ref,<<"apos">>},
                                    <<"d">>]},
                                  {element,<<"wibble">>,#{},[<<"junk">>]},
                                  {element,<<"trig:afterValue">>,
                                   #{<<"abc">> => <<"12&quot;3">>},
                                   [<<"Value that exists now">>]}],
                                 [{element,<<"trig:beforeValue">>,#{},
                                   [{comment,<<" test comment ">>},
                                    <<"[\"AACY\",\"BBIB\",\"BERRY\"]">>]},
                                  {element,<<"trig:afterValue">>,#{},
                                   [<<"[\"AACY\",\"BBIB\",\"BERRY\",\"CLONE\",\"FUP\"]">>]}]]}},
                         'Header' =>
                          [[{element,<<"urn:Trans">>,#{},
                             [{element,<<"urn:serviceName">>,#{},
                               [<<"UPCC.EE">>]},
                              {element,<<"urn:msgId">>,#{},[<<"0">>]},
                              {element,<<"urn:connId">>,#{},[<<"0">>]}]}]]}}.

```




# Generation, extraction of message values


Example of a PACS.008 message generated with random values, decoded, and the
specified values extracted to a nested map:

```
1> flow_pacs_test:test().
{#{'Document' =>
     #{'FIToFICstmrCdtTrf' =>
       #{'GrpHdr' =>
         #{'MsgId' => [[<<"7yz2 fqaJiMDrS1tG0N0rq">>]],
           'CreDtTm' => [[<<"2024-05-16T13:08:09">>]],
           'NbOfTxs' => [[<<"33402068860">>]],
           'SttlmInf' => #{'SttlmMtd' => [[<<"INDA">>]]}},
         'CdtTrfTxInf' =>
           #{'PmtId' => #{'EndToEndId' => [[<<"tS1WHpd0CYk5Cw6E">>]]},
             'IntrBkSttlmAmt' => [[<<"4828.28005">>]],
             'ChrgBr' => [[<<"SHAR">>]],
             'Dbtr' =>
               #{'Nm' => [[<<"3Ywlp9JWSEIx5EGnWsf">>]],
                 'PstlAdr' =>
                     #{'AdrTp' => #{'Cd' => []},
                       'StrtNm' =>
                           [[<<"aVAnzHRhGresXP734zBI6PlAtHF1PfB0ecZtejjBnszpg34cnmcsqthkxtfC">>]],
                       'BldgNb' => [[<<"iiPCqFz5FIz53AU5">>]],
                       'PstCd' => [[<<"zN">>]],
                       'TwnNm' => [[<<"OdI ">>]],
                       'DstrctNm' =>
                           [[<<"iYs4PNsZS56 lOYnOyj6LWoaUPB6t">>]]},
                 'CtryOfRes' => [[<<"GZ">>]]},
             'DbtrAgt' =>
                 #{'FinInstnId' =>
                       #{'BICFI' => [[<<"D3V1XXZOZ8R">>]]}},
             'CdtrAgt' =>
                 #{'FinInstnId' =>
                       #{'BICFI' => [[<<"8AR1MQNYXM3">>]]}},
             'Cdtr' =>
                 #{'Nm' =>
                     [[<<"X8MGKZfzej26OgQFDuSG5oWXctW0eAoJf2Mjmf1 1EkCcPKqy8gibpwsoD 2I2C8yEoll88wN1nzVgf">>]],
                   'PstlAdr' =>
                     #{'AdrTp' => #{'Cd' => [[<<"BIZZ">>]]},
                       'StrtNm' =>
                           [[<<"a8TjvWRtO9JEOD6tHGWiD1yH1nVWbcVJEL4KK7OoT40DA4ezC9M5ZMxCromLkwwls8V">>]],
                       'BldgNb' => [[<<"omhAr">>]],
                       'PstCd' => [[<<"RSTMz9E">>]],
                       'TwnNm' => [[<<"QFS">>]],
                       'DstrctNm' => [[<<"nXJG6E">>]]}}}}}},
 [{prolog,<<"xml version=\"1.0\" encoding=\"UTF-8\" ">>},
  {element,<<"Document">>,
      #{<<"xmlns">> =>
            <<"urn:iso:std:iso:20022:tech:xsd:pacs.008.001.11">>},
      [{element,<<"FIToFICstmrCdtTrf">>,#{},
           [{element,<<"GrpHdr">>,#{},
                [{element,<<"MsgId">>,#{},[<<"7yz2 fqaJiMDrS1tG0N0"...>>]},
                 {element,<<"CreDtTm">>,#{},[<<"2024-05-16T13:08"...>>]},
                 {element,<<"BtchBookg">>,#{},[<<"FALSE">>]},
                 {element,<<"NbOfTxs">>,#{},[<<"33402068"...>>]},
                 {element,<<"CtrlSum">>,#{},[<<"89.0"...>>]},
                 {element,<<"TtlIntrBkStt"...>>,
                     #{<<"Ccy">> => <<"BQT">>},
                     [<<...>>]},
                 {element,<<"IntrBkSt"...>>,#{},[...]},
                 {element,<<"Sttl"...>>,#{},...},
                 {element,<<...>>,...},
                 {element,...},
                 {...}]},
            {element,<<"CdtTrfTxInf">>,#{},
                [{element,<<"PmtId">>,#{},
                     [{element,<<"InstrId">>,#{},[...]},
                      {element,<<"EndT"...>>,#{},...},
                      {element,<<...>>,...},
                      {element,...},
                      {...}]},
                 {element,<<"PmtTpInf">>,#{},
                     [{element,<<"Inst"...>>,#{},...},
                      {element,<<...>>,...},
                      {element,...},
                      {...}|...]},
                 {element,<<"IntrBkSttlmAmt">>,
                     #{<<"Ccy">> => <<"YZB">>},
                     [<<"4828.280"...>>]},
                 {element,<<"IntrBkSttlmDt">>,#{},[<<"2024"...>>]},
                 {element,<<"SttlmPrty">>,#{},[<<...>>]},
                 {element,<<"SttlmTmI"...>>,#{},[...]},
                 {element,<<"Sttl"...>>,#{},...},
                 {element,<<...>>,...},
                 {element,...},
                 {...}|...]},
            {element,<<"SplmtryData">>,#{},
                [{element,<<"PlcAndNm">>,#{},[<<"wBFGLIv62SvT"...>>]},
                 {element,<<"Envlp">>,#{},[{'CDATA',<<...>>}]}]}]}]}]}


```